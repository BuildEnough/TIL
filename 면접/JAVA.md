### 1. 자바의 특징
- JVM 위에서 실행되기 때문에 OS에 종속적이지 않고, 독립적으로 실행
- 클래스로더에 의해 동적 로딩을 지원합니다.
- 실행 시 모든 객체를 생성하는 것이 아니라, 필요한 시점에 클래스를 생성
- 기본 자료형 8개를 제외한 모든 요소들이 객체로 표현됨
- 객체지향언어의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
- 장점으로 JVM 위에서 동작하기 때문에 운영체제에 독립적이고 Gabage Collcetor 을 통한 자동적인 메모리 관리가 가능합니다.
- 단점으로 JVM 위에서 동작하기 때문에 실행속도가 느리고, 다중상속이나 타입에 엄격하며 제약이 많습니다


### 2. 자바의 컴파일 과정을 설명해주세요
- .java 파일 생성 후 build를 합니다.
- 자바 컴파일러 javac의 명령어를 통해 바이트코드 .class 파일을 생성
- Class Loader가 .class 바이트 코드를 런타임 데이터 영역인 JVM 메모리로 로드하고
- 로딩된 바이트 코드가 실행엔진에 의해 각 OS에 맞는 기계어로 해석되어 실행됩니다.


### 3. JVM에 대해 설명해보세요
- 자바 바이트 코드를 OS에 맞게 해석 해주는 역할을 하고 Gabage Collcetion을 통해 자동적인 메모리 관리를 해줍니다


### 4. 자바에서 제공하는 원시타입과 각각 몇 바이트인지 설명하세요
- 총 8가지 원시타입이 존재하고 stack 영역에 저장됨
- 정수형 byte, short, int, long이 있고 1byte, 2byte, 4byte, 8byte입니다.
- 실수형 float, double가 있고 4byte, 8byte 입니다.
- 문자형 char은 2byte이고
- 논리형 boolean은 1byte 입니다.


### 5. 자바의 메모리 구조에 대해 설명해주세요
- Method, Stack, Heap 영역으로 구분됩니다.
- Method 영역엔 전역 변수, static 변수, 메소드 코드, 생성자 코드 등의 정보들이 저장되며 바이트 코드를 읽은 내용이 저장되는 영역입니다.
- Stack 영역은 호출된 메소드의 매개변수, 지역변수, 리턴 정보들이 저장되고
메소드가 호출될 때 메모리에 할당되며 종료되면 메모리가 해제됩니다.
LIFO 구조로 변수에 새로운 데이터가 할당되면 이전 데이터는 지워집니다.
즉, 메소드를 호출할 때마다 생성되는 영역입니다.
- Heap 영역은 런타임 중에 생성되는 객체들이 동적으로 할당되는 곳이며, 
new 키워드로 생성되는 객체의 배열 등이 저장되며 Gabage Collcetion에 의해 관리됩니다.


### 6. GC에 대해 설명해주세요
- 가비지 컬렉션은 JVM에서 메모리를 관리해주는 모듈입니다.
- 힙 메모리를 재활용하기 위해 더 이상 참조되지 않은 객체들을 메모리에서 제거하는 모듈입니다.
- 따라서 개발자가 직접 메모리를 관리하지 않아도 돼서 개발 속도가 향상되는 장점이 있지만,
참조되지 않은 객체를 찾는 과정인 mark and sweep 과정에서 쓰레드가 잠시 중단되어 성능이 떨어진다는 단점이 있습니다.


### 7. 오버라이딩과 오버로딩에 대해 설명해보세요
- 오버로딩은 메소드의 이름은 동일하지만 매개변수가 다른 메소드를 만들어 다양한 상황에서 메소드가 호출 될 수 있도록 합니다.
- 오버라이딩은 부모 클래스가 가지고 있는 메소드를 자식 클래스에서 재정의하여 사용하는 것을 말합니다.


### 8. 객체지향에 대해 설명해보세요.
현실세계의 사물과 같은 객체를 만들고 그 객체가 필요한 특징을 뽑아서 프로그래밍을 수행하는 것입니다.  
객체지향의 4가지 특징이 있는데 추상화, 캡슐화, 상속, 다형성의 특징이 있습니다.

추상화는 물과 음료수가 있을 때 마시는 것처럼 공통적인 특징을 하나의 개념으로 뽑아내는 것을 의미합니다.

캡슐화는 각각의 객체들안에 외부에 숨겨야하는 정보를 숨기고 공개해야하는 정보는 공개하는 것을 의미합니다.  
외부와 연결이 많이 되면 안좋은데 이것을 결합도가 높다라고 합니다.  
안좋은 이유로 외부와 만약 연결이 안 될 경우 의존된 것을 사용할 수 없기 때문입니다.  
따라서 외부적으로 결합도가 높은 것보다 내부적으로 높은 응집도를 가지는 것이 좋습니다.

상속은
인터페이스 없이 애플리케이션을 개발하면 클라이언트 코드가 구체적인 클래스에 의존하게 되고,
하나의 클래스가 변경되면 다른 클래스도 계속해서 변경해 줘야 하는 문제가 생깁니다.  
이런 문제를 해결하려면 클라이언트 코드가 구체적인 클래스가 아니라 인터페이스에 의존해야 합니다.  
결국 클라이언트 코드와 구체적인 클래스 모두 인터페이스에 의존하게 되는 것입니다.  
예를 들어 A클래스와 B클래스에 같은 코드가 셀 수 없을만큼 있을 때 공통된 코드가 수정될 경우 A클래스와 B클래스 모두 수정 해줘야 합니다.  
상속을 사용하면 A클래스를 B클래스가 상속받아 A클래스의 코드만 수정해주면 B 클래스에서 수정해줄 필요가 없고 코드의 오류 또한 막을 수 있습니다.

다형성은 
인터페이스의 레퍼런스 변수는 해당 인터페이스를 구현하는 여러 클래스들의 인스턴스를 담을 수 있습니다.  
그리고 레퍼런스 변수 안에 어떤 인스턴스가 들어 있는지 신경 쓰지 않고
메서드를 호출하면 안에 들어 있는 인스턴스의 종류에 따라 완전히 다른 동작이 실행될 수 있습니다.  
즉, 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 것을 의미합니다



### 9. 추상클래스와 인터페이스의 차이를 설명해보세요
- 추상클래스는 abstract 지시자로 정의되며 추상 메서드가 하나 이상 포함되어야 하는 클래스이고
- 인터페이스는 interface 지시자로 정의되며 모든 메소드가 추상 메소드로 정의됩니다.
- 하지만 자바 8부터 interface에서도 메소드를 구현할 수 있게 되었습니다.
- 공통점으로 new 연산자로 인스턴스 생성이 불가능하고 사용하기 위해 하위 클래스에서 확장/구현 해야 하는 특징이 있습니다.
- 차이점으로 추상클래스는 부모 클래스의 기능을 상속받아 재활용하여 확장시키는 목적이 있고
- 인터페이스는 함수의 구현을 강제하기 때문에 구현한 객체들이 같은 동작을 하는 것을 보장하는 것이 목적입니다.
- 인터페이스는 해당 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재해야하고
- 추상클래스는 다중상속이 불가능하지만 인터페이스는 가능하다는 점이 있습니다.


### 10. 생성자에 대해 설명해보세요
- 생성자는 클래스와 같은 이름의 메소드로 객체가 생성될 때 호출되는 메서드 생성자의 파라미터를 다르게 하여 오버로딩할 수 있습니다
- 만약 생성자를 만들지 않을 경우 자동으로 기본 생성자가 생성되고, 생성자를 1개라도 생성할 경우 기본 생성자는 생성되지 않습니다.


### 11. 객체지향의 5가지 설계원칙에 대해 설명해보세요
SRP는 단일책임원칙으로 한 클래스는 하나의 책임만 가져야 한다는 원칙으로
결합도는 낮게 응집도는 높게 설계하는 것을 의미합니다.

OCP는 개방 폐쇄의 원칙으로 확장에는 열여있고 수정에는 닫혀있어야 한다는 원칙이고
공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적입니다.

LSP는 리스코프 치환 원칙으로 자식 클래스는 최소한 부모의 클래스에서 가능한 행위는 수행할 수 있어야 한다는 원칙이고
자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 하는 것입니다.

ISP는 인터페이스 분리원칙으로 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙이고
단일책임원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리원칙은 인터페이스가 갖는 하나의 책임입니다.

DIP는 의존관계 역전 원칙으로 각 객체들 간의 의존 관계가 성립할 때, 
추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어 변하지 않을 가능성이 높은 클래스와 관계를 맺는 원칙입니다.


### 12. 접근 제한자에 대해 설명해보세요
- 변수 또는 메소드의 접근 범위를 설정해 주기 위해 사용하는 자바의 예약어로
public, protected, default, private가 있습니다.
- public은 접근 제한이 없고
- protected는 해당 패키지와 다른 패키지에서 상속받아 자손 클래스에서 접근 가능합니다.
- default는 해당 패키지 내에서만 접근 가능하며
- private는 해당 클래스에서만 접근 가능합니다.


### 13. static에 대해 설명해주세요
- static을 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 로딩이 끝나면 바로 사용할 수 있습니다.
- 즉, 인스턴스 객체 생성없이 사용가능합니다.
- 모든 객체가 메모리를 공유한다는 특징이 있고, GC 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지됩니다.
- 따라서 자주 변하지 않는 값이나 공통으로 사용되는 값같은 공통된 자원에 주로 사용합니다.


### 14. 자바의 ==과 equals()의 차이에 대해 설명하세요
- ==은 두 객체가 같은 메모리 공간을 가리키는 지를 나타내고
- equals()는 두 객체의 내부 값이 같은지 비교합니다.


### 15. 자바의 hashCode에 대해 설명해주세요
- 두 객체가 동일한 객체인지 비교할 때 사용하고, 힙 영역에 저장된 객체의 메모리 주소를 반환합니다


### 16. 자바의 Wrapper Class에 대해 설명해주세요
- 원시자료형 타입의 데이터를 객체로 취급해야 할 경우 사용하는 클래스로, 기본 타입의 데이터를 객체로 변환해주는 클래스입니다
- 따라서 기본 타입의 데이터를 객체 타입으로 Boxing하면 ==으로 비교하는 것이 아닌, equals()로 비교해야 합니다.
- 기본 타입의 변수를 래퍼클래스의 인스턴스로 변경하는 과정을 Boxing, 래퍼클래스의 인스턴스를 다시 기본 타입으로 꺼내는 과정을 UnBoxing


### 17. 자바의 main 메소드가 static인 이유는 무엇인가요?
- static 멤버는 프로그램 시작 시, 클래스 로더에 의해 메모리에 로드되어 인스턴스를 생성하지 않아도 호출이 가능하기 때문입니다.


### 18. 제네릭에 대해 설명해보세요
- 클래스 내부에서 타입을 지정하는 것이 아닌, 외부에서 사용자에 의해 지정되는 것
- 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적으로 지정한다는 의미입니다.
- 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있습니다.


### 19. static 메소드가 instance 변수를 사용할 수 없는 이유를 설명해주세요
- static 메소드는 항상 호출 가능한 메서드인데, static 메서드를 호출할 때 인스턴스 변수를 사용할 객체가 보장되어 있지 않기 때문에 사용할 수 없습니다.
- 만약 정적 메서드와 정적 블록에서 인스턴스 멤버를  사용하고 싶다면 main 메서드와 같이 	객체를 먼저 생성하고 사용해야 합니다.


### 20. 싱글톤 패턴에 대해 설명해주세요
- 애플리케이션 전체에서 단 한 개의 객체만 생성해서 사용하고 싶은 경우에 사용합니다.
- 생성자를 private로 제한해서 외부에서 new 연산자로 생성자를 호출할 수 없게 합니다.
- 외부에서 객체를 얻는 방법은 getInstance()로 메소드를 호출하는 방법만 있습니다.
- 스프링의 빈 등록방식은 기본적으로 싱글톤 방식이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다.


### 21. super()에 대해 설명해주세요
- super()는 컴파일 과정에서 자동추가되는데 이것은 부모의 기본 생성자를 호출해줍니다.
- 만약 부모 클래스에 기본 생성자가 없다면 자식 클래스에서 에러가 발생합니다.
- 부모 클래스에 기본 생성자가 없고 매개변수를 갖는 생성자만 있다면 자식 클래스에서 매개값과 타입이 맞는 super() 생성자를 호출해야 합니다.


### 22. super.에 대해 설명해주세요
- 메소드 오버라이딩에서 부모 메소드가 100줄을 가지고 있고
- 자식 클래스에서 메소드를 재정의 할 때 1줄만 변경되더라도 
- 100줄의 코드를 자식 클래스에서 다시 작성해야하는데
- 이때 super.을 사용하여 부모의 메서드를 호출할 수 있습니다.

### 23. try-catch-finally의 단점과, 이로 인해 나온 구문에 대해 알고 계신다면 설명해주세요
- try-catch-finally 구문에서 리소스를 생성하게 되면, 생성은 try에서 하고 반납은 finally에서 하다보니 실수의 발생 여지가 있었습니다.
- 그래서 나온 구문으로 try-with-resources가 있습니다. try 옆에 괄호로 리소스를 생성해주면, 따로 반납 코드를 작성하지 않아도 자동으로 리소스를 반납합니다.

### 24. Error과 Exception의 차이점에 대해 설명해주세요
- Error은 복구 불가능하고 런타임에서 발생하며, 컴파일 시점에서 알 수 없다
- Exception은 try-catch를 이용하여 복구 가능하고, 런타임 시점에 알 수 있다

### 25. String에 대해 설명해주세요
- String은 새로운 값을 할당할 때마다 새로운 동적 변수(인스턴스)가 생성된다
- String에 저장된 문자열은, 내부적으로 private final char[] 형태이므로 변경이 불가능합니다.
- String에 대한 연결 연산으로 '+'를 사용하면, 두 String을 연결한 새로운 객체가 생성됩니다.
- 가비지 컬렉터가 호출되기 전까지 생성된 String 객체들은 Heap에 계속해서 머물기 때문에 메모리 관리 측면에서 치명적입니다.

### 26. StringBuilder에 대해 설명해주세요
- String과 다르게 가변성을 가지는 클래스
- append(), delete()등의 method를 사용해 동일 객체 내에서 문자열을 변경하는 것이 가능합니다
- 동기화를 지원하지 않기 때문에, 멀티 쓰레드 환경에서 사용하는 것은 적합하지 않지만, 동기화를 고려하지 않는 만큼 단일쓰레드에서의 성능은 StringBuffer보다 뛰어납니다.

### 27. StringBuffer에 대해 설명해주세요
- String과 다르게 가변성을 가지는 클래스입니다. append(), delete()등의 method를 사용해 동일 객체 내에서 문자열을 변경하는 것이 가능합니다.
동기화를 지원하기 때문에 멀티 쓰레드 환경에서 thread-safe합니다.

### 28. ""과 new String("")의 차이에 대해 설명해주세요
- ""으로 문자열을 초기화 하게 되면, Java Heap 메모리의 String Pool에 저장이 됩니다.
```java
String msg1 = "hello";
String msg2 = "hello";
```
- 위의 코드의 "hello"는 Java Heap 메모리의 String Pool에 저장되고, msg1과 msg2는 같은 String pool 내의 "hello"를 가리키게 됩니다.
- new String("")은 new 키워드를 사용해 새로 생성했기 때문에 Heap 영역에 각각 생성됩니다. 따라서 msg3와 msg4는 서로 다른 주소를 가리키고 있는 상태입니다.
```java
String msg3 = new String("hello");
String msg4 = new String("hello");
```